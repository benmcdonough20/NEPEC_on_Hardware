\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amssymb, amsmath, amsthm, physics, graphicx, fancyhdr, cancel}
\usepackage{pythontex}
\chead{Title}
\lhead{Ben McDonough}
\rhead{Class}
\pagestyle{fancy}

\newcommand{\vectorize}[1]{\operatorname{vec}\left[#1\right]}
\newcommand{\kket}[1]{\vert #1 \rangle  \rangle}
\newcommand{\bbra}[1]{\langle  \langle #1 \vert}

\begin{document}
\thispagestyle{empty}
\noindent Ben McDonough\\
\noindent \today\\
\centerline{\huge Pauli-Lindblad Model in Python}\\ \\
\section*{Introduction}
This notebook is a \textit{Qiskit} simulation of the Sparse Pauli-Lindblad models discussed in \textit{Probabilistic error cancellation with sparse Pauli-Lindblad models on noisy quantum processors}. This paper descirbes a method for reducing the complexity of error models by expoiting the locality of noise on a quantum preocessor. The notebook is a python implementation of the Lindbladian described as an enactable noise model in qiskit.

\section{Model parameters}
\subsection*{Definitions}
The second cell provies a list of parameters included in the model. These include
\begin{itemize}
    \item $n$ - the number of simulated qubits
    \item $\kappa$ - the set of the Pauli operators considered in the model
    \item $K = |\kappa|$
    \item $\vec \lambda$ - the weights of each operation in the Lindbladian.
\end{itemize}
In the notebook, these parameters are included in the following variables:
\begin{itemize}
    \item $n$ = n
    \item $\kappa$ = pauli\_list
    \item $K$ = K
    \item $\vec \lambda$ = coeffs
\end{itemize}

\subsection*{Notes}
If the Pauli error model is used, then $\kappa$ must be the full set of Pauli-operators, including the identity, otherwise the coefficients in the process matrix $\chi$ will not be normalized. I am not quite sure why this happens, but I suspect it has something to do with the rank of the Walsh-Hadamard transformation, which is used to convert the transfer matrix into the process matrix. It would be interesting to see if another set of operators would also need to span the Hilbert-Schmidt space. In the model, the weights of these can be set to zero. If a sparse set $\kappa$ is used, then the Kraus error model will still work, but the Pauli model will break.

\section*{Kraus error model}
Using equation (S9), the error model gives an evolution operator over a certain period of time to be
$$
\vectorize{\Lambda} = \qty(\omega_1 I \otimes I+(1-\omega_1)P^\top \otimes P) \circ\qty(\omega_2 I \otimes I+(1-\omega_2)P^\top \otimes P) \circ ... \circ \qty(\omega_K I \otimes I+(1-\omega_K)P^\top \otimes P)
$$
Where the coefficients $\omega_k$ are derived from the coefficients in the Lindbladian $\lambda_k$ via
$$
\omega_k = \frac{1}{2}(1+e^{-2\lambda_k})
$$
I reworked the proof for this below. The Kraus error model is formed by computing $\omega_k$ for the $K$ Pauli operators in the model, and then composing the operators together. As discussed in the paper, the terms in this product are mutually commuting, so there is no ambiguity in the order of the composition. Since each term in the product is a sum of two operations, and there are $K$ terms, there are a total of $2^K$ Kraus operators in the model. The Kraus representation is not efficient in comparison with the sparse Pauli representation.
\par Once the Kraus operators are obtained, they can be used to create a 
\begin{pyverbatim}
    qiskit.providers.aer.noise.kraus_error
\end{pyverbatim}
This can then be used along with a simulator to model this error acting on every gate. 

\section*{Pauli Error Model}
The fidelities are the scaled expectation values of the Pauli operators, as given in equation (S10)
$$
f_a = \frac{1}{2^n}\Tr{P_a^\dagger \Lambda(P_a)} = e^{-2\sum_{\langle a,b \rangle_{sp}}\lambda_k}
$$
Where $\langle a,b \rangle_{sp}$ is $0$ when $[P_a, P_b] = 0$ and $1$ otherwise. I worked out the proof for this below. This equation can be rewritten as the vector equation
$$
\vec f = e^{-2M\vec \lambda}
$$
Where the exponent is taken component-wise, and the matrix $M$ is defined as $M_{a,b} = \langle a,b \rangle_{sp}$. This is an inverstion of equation (S11). This equation is used to find the ideal fidelities $\vec f_a$, which are the eigenvectors of the transfer matrix defined in terms of the Hilbert-Schmidt inner product as
$$
(R_\lambda)_{a,b} = \bbra{a} R_\lambda \kket{b} = \frac{1}{2^n}\Tr{P_a^\dagger \Lambda(P_b)}
$$
In the case of the twirled noise, this matrix is diagonal in the Pauli basis $\kket{a} = \frac{1}{\sqrt{2^n}} \kket{P_a}$. Since the expansion of the noise channel $\Lambda$ includes strings of Pauli operators, and Pauli operators have group closure, is follows that the process matrix $\chi$ is also diagonal in the Pauli basis, and the channel can be expressed
$$
\Lambda(\rho) = \sum_{a,b} \chi_{ab}P_a\rho P_b^\dagger = \sum_P{i} \chi_{ii} P_i \rho P_i
$$
As shown below, the fidelities $f_a$ can be converted to the process matrix coefficients using the Walsh-Hadamard transformation
$$
\chi_{ii} = \frac{1}{2^n}\sum_j (-1)^{\langle i,j \rangle_{sp}}f_j
$$
I would like to note that using this formula produced an incorrect normalization, and I cannot figure out why. These coefficients were then used to construct a
\begin{pyverbatim}
qiskit.providers.aer.noise.pauli_error
\end{pyverbatim}
This noise model can then be applied to the simulator. I checked to see if the Kraus channel and the Pauli channel were equivalent, and although they produced similar expectation values, they are not detected by qiskit to be equivalent. I wonder if this is a real error or is due to precision loss. Interestingly, the Pauli channel model is also a less efficient representation than the sparse model.

\section*{Learning the fidelities}


\section*{Proofs}
\subsection*{Factorized Noise}
I wanted to work through this proof myself. Beginning with quantum jump operators
$$
L_k = \sqrt{\lambda_k}P_k
$$
The Lindblad master equation can be constructed:
$$
\dv{\rho}{t} = -i[H, \rho]+\sum_k\qty(L_k \rho L_k^\dagger - \frac{1}{2}\{L_k^\dagger L_k, \rho\}) = -i[H, \rho]+\sum_k \qty(P_k \rho P_k - \rho)
$$
To construct the noise model, the coherent evolution due to the Hamiltonian is nelgected, and the master equation becomes
$$
\dv{\rho}{t} = \sum_k \qty(P_k \rho P_k - \rho)
$$
The can be represented as superoperators by vectorizing the matrices, where $\kket{\rho}$ is a vector with the columns of $\rho$ stacked on top of each other. ROth's Lemma gives the following identity:
$$
\vectorize{ABC} = B^\top \otimes A \kket{\rho}
$$
Using this, the master euqation cdan be vectorized:
$$
\dv{t}\kket{\rho} = \qty(\sum_k \lambda_kP_k^\top \otimes P_k - \lambda_kI\otimes I)
$$
As long as $\lambda_k$ do not depend on time, the equation has the solution
$$
\kket{\rho(T)} = e^{T\sum_k\lambda_kP^\top \otimes P_k -\lambda_k I\otimes I}\kket{\rho(0)}
$$
Absorbing the evolution time $T$ into the coefficients $\lambda_k$, the resulting noise channel is
$$
 \rho' = \Lambda\kket{\rho} = e^{\sum_k\lambda_kP_k^\top \otimes P_k -\lambda_k I\otimes I} \kket{\rho} = e^{\sum_k \mathcal{L}_k }
$$
Where we let $\mathcal{L}_k \equiv P_k^\top \otimes P_k -\lambda_k I\otimes I$. Then, the operators $P_a$ and $P_b$ either commute or anticommute as Paulioperators, so
$$
P_aP_b = \pm P_bP_a
$$
With this we find
\begin{align*}
    \mathcal{L}_a\mathcal{L_b} &= \lambda_a\lambda_b\qty(P_a^\top \otimes P_k -\lambda_k I\otimes I)\qty(P^\top \otimes P_k -\lambda_k I\otimes I)\\
                               &= \lambda_a \lambda_b\qty(P_a^\top P_b^\top\otimes P_a P_b-P_a^\top \otimes P_a - P_b^\top \otimes P_b + I \otimes I)\\
                               &= \lambda_a \lambda_b\qty((P_bP_a)^\top\otimes P_a P_b-P_a^\top \otimes P_a - P_b^\top \otimes P_b + I \otimes I)\\
                               &= \lambda_a \lambda_b\qty((\pm P_aP_b)^\top\otimes (\pm P_b P_a)-P_a^\top \otimes P_a - P_b^\top \otimes P_b + I \otimes I)\\
                               &= \lambda_a \lambda_b\qty((\pm P_aP_b)^\top\otimes (\pm P_b P_a)-P_a^\top \otimes P_a - P_b^\top \otimes P_b + I \otimes I)\\
                               &= \lambda_a \lambda_b\qty((P_aP_b)^\top\otimes (P_b P_a)-P_a^\top \otimes P_a - P_b^\top \otimes P_b + I \otimes I)\\
                               &= \lambda_a \lambda_b\qty(P_b^\top P_a^\top\otimes P_b P_a-P_a^\top \otimes P_a - P_b^\top \otimes P_b + I \otimes I)\\
                               &= \mathcal{L}_b \mathcal{L}_a
\end{align*}
Since $\mathcal{L}_a$ commutes with $\mathcal{L_b}$ for every pair $a,b$, the Baker-Campbell-Hausdorff identity says that
$$
\Lambda = e^{\sum_k \mathcal{L}_k} = \prod_k e^{mathcal{L}_k}
$$
\subsection*{Walsh-Hadamard transform is involutory}

\subsection*{Transfer matrix to Process Matric conversion}

\subsection*{Pauli matrices are eigenvectors of Pauli Channel}

\end{document}
